import numpy as np
from scipy.interpolate import PchipInterpolator
from src.models.hjm import HJM
from src.config import SIM_YEARS, SIM_PATHS, SIM_METHOD, SEED

class Cheyette(HJM):

    def __init__(self, times, yields, kappa, sigma, dt):
        # yield curve
        self.curve_spline = PchipInterpolator(times, yields)
        # log-disc factors: ln(P(0,t)) = -r(t)*t
        log_p_values = -np.array(yields) * np.array(times)
        # disc factor curve
        self.log_p_spline = PchipInterpolator(times, log_p_values)
        # instantaneous forward rate f(0,t) = -d/dt ln(P(0,t))
        self.d_log_p_dt = self.log_p_spline.derivative(nu=1)
        
        # mean reversion
        self.kappa = kappa
        self.dt = dt
        # vol
        self.volatility_factors = np.array([[sigma]])
        self.tenors = times 
        
    def zc_price_market(self, T):
        """ zcb price P(0, T) """
        if T <= 1e-8: 
            return 1.0
        return np.exp(self.log_p_spline(T))
        
    def get_instantaneous_forward_rate(self, t):
        """ f(0,t) used in simulation drift """
        if t <= 1e-8: 
            return -self.d_log_p_dt(1e-8)
        return -self.d_log_p_dt(t)
    
    def simulate(self, current_curve=None, n_years=SIM_YEARS, n_sims=SIM_PATHS, method=SIM_METHOD, seed=SEED):
        sigma = self.volatility_factors[0, 0]
        kappa = self.kappa
        dt = self.dt
        n_steps = int(n_years / dt)
        
         # simulation timeline
        sim_times = np.arange(n_steps + 1) * dt

        # Musiela-style forward grid: f(t, u) with u = time-to-maturity grid (self.tenors)
        # -> built from initial curve as f(0, t+u) -> no negative maturities
        shifted_maturities = sim_times[:, np.newaxis] + self.tenors[np.newaxis, :]
        f_0_shifted = np.array(
            [[self.get_instantaneous_forward_rate(mat) for mat in row] for row in shifted_maturities]
        )

        # align model curve to current market curve        
        if current_curve is not None:
            base_yields = self.curve_spline(self.tenors)
            bump = current_curve - base_yields
            f_0_shifted = f_0_shifted + bump[np.newaxis, :]

        # brownian increments -> (n_sims_adjusted, n_steps, factors)
        dW_full = self.prepare_drivers(n_steps, n_sims, method, seed)
        
        # extract single factor for Cheyette
        dW = dW_full[:, :, 0]
        
        # actual number of paths generated by Sobol
        real_n_sims = dW.shape[0]

        # state variables
        x = np.zeros((n_steps + 1, real_n_sims))
        y = np.zeros((n_steps + 1, real_n_sims))
        # short rate
        r_t = np.zeros((n_steps + 1, real_n_sims)) 
        
        # Initial f(0,0)
        f_0_0 = self.get_instantaneous_forward_rate(0)
        # r(0) = f(0,0)
        r_t[0] = f_0_0
        
        for t in range(n_steps):
            x_t = x[t]
            y_t = y[t]
            
            # x increments
            dx = (y_t - kappa * x_t) * dt + sigma * dW[:, t]
            # y increments
            dy = (sigma**2 - 2 * kappa * y_t) * dt
            
            # updates 
            x[t+1] = x_t + dx
            y[t+1] = y_t + dy
            
            # reconstruct short rate for next step
            time_next = (t + 1) * dt
            f_0_next = self.get_instantaneous_forward_rate(time_next)
            # update short rate
            r_t[t+1] = f_0_next + x[t+1] + y[t+1]

        # forward Curve reconstruction
        # => f(t, T) = f(0,T) + x(t)e^{-k(T-t)} + y(t)e^{-2k(T-t)}
        
        x_exp = x[:, :, np.newaxis]
        y_exp = y[:, :, np.newaxis]
        tenor_grid = self.tenors[np.newaxis, np.newaxis, :]
        
        # Musiela -> exponential loadings depend on time-to-maturity only
        coeff_x = np.exp(-kappa * tenor_grid)
        coeff_y = np.exp(-2 * kappa * tenor_grid)

        # broadcast baseline
        f_0_grid = f_0_shifted[:, np.newaxis, :]

        # simulated forward paths f(t, u)
        paths = f_0_grid + (x_exp * coeff_x) + (y_exp * coeff_y)
       
        # tuple (paths, x, y, r_t)
        return paths, x, y, r_t